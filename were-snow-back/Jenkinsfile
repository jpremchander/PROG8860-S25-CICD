pipeline {
    agent any
    
    environment {
        DOCKER_IMAGE = 'snowbored-game'
        DOCKER_TAG = "${BUILD_NUMBER}"
        DOCKER_REGISTRY = credentials('docker-hub-credentials')
        NODE_VERSION = '18'
    }
    
    tools {
        nodejs "${NODE_VERSION}"
    }
    
    stages {
        stage('Checkout') {
            steps {
                echo 'Checking out source code...'
                checkout scm
                
                script {
                    env.GIT_COMMIT_SHORT = sh(
                        script: "git rev-parse --short HEAD",
                        returnStdout: true
                    ).trim()
                }
            }
        }
        
        stage('Build') {
            steps {
                echo 'Installing dependencies and building application...'
                sh '''
                    echo "Node version: $(node --version)"
                    echo "NPM version: $(npm --version)"
                    
                    # Clean install dependencies
                    npm ci
                    
                    # Run linting
                    npm run lint
                    
                    # Build the application
                    npm run build
                '''
            }
            post {
                success {
                    echo 'Build completed successfully!'
                }
                failure {
                    echo 'Build failed!'
                }
            }
        }
        
        stage('Test') {
            parallel {
                stage('Unit Tests') {
                    steps {
                        echo 'Running unit tests...'
                        sh '''
                            # Run tests with coverage
                            npm test -- --coverage --watchAll=false --ci
                        '''
                    }
                    post {
                        always {
                            // Publish test results
                            publishTestResults testResultsPattern: 'coverage/lcov.info'
                            
                            // Archive coverage reports
                            publishHTML([
                                allowMissing: false,
                                alwaysLinkToLastBuild: true,
                                keepAll: true,
                                reportDir: 'coverage/lcov-report',
                                reportFiles: 'index.html',
                                reportName: 'Coverage Report'
                            ])
                        }
                        success {
                            echo 'All tests passed!'
                        }
                        failure {
                            echo 'Tests failed! Pipeline will be aborted.'
                            error('Test stage failed')
                        }
                    }
                }
                
                stage('Security Scan') {
                    steps {
                        echo 'Running security audit...'
                        sh '''
                            # Run npm audit
                            npm audit --audit-level moderate || true
                        '''
                    }
                }
            }
        }
        
        stage('Docker Build') {
            steps {
                echo 'Building Docker image...'
                script {
                    def dockerImage = docker.build("${DOCKER_IMAGE}:${DOCKER_TAG}")
                    
                    // Tag with latest
                    sh "docker tag ${DOCKER_IMAGE}:${DOCKER_TAG} ${DOCKER_IMAGE}:latest"
                    
                    // Tag with git commit
                    sh "docker tag ${DOCKER_IMAGE}:${DOCKER_TAG} ${DOCKER_IMAGE}:${env.GIT_COMMIT_SHORT}"
                }
            }
            post {
                success {
                    echo 'Docker image built successfully!'
                }
                failure {
                    echo 'Docker build failed!'
                }
            }
        }
        
        stage('Docker Push') {
            when {
                anyOf {
                    branch 'main'
                    branch 'master'
                    branch 'develop'
                }
            }
            steps {
                echo 'Pushing Docker image to registry...'
                script {
                    docker.withRegistry('https://registry.hub.docker.com', 'docker-hub-credentials') {
                        sh """
                            docker push ${DOCKER_REGISTRY_USR}/${DOCKER_IMAGE}:${DOCKER_TAG}
                            docker push ${DOCKER_REGISTRY_USR}/${DOCKER_IMAGE}:latest
                            docker push ${DOCKER_REGISTRY_USR}/${DOCKER_IMAGE}:${env.GIT_COMMIT_SHORT}
                        """
                    }
                }
            }
            post {
                success {
                    echo 'Docker image pushed successfully!'
                    
                    // Send notification
                    slackSend(
                        channel: '#deployments',
                        color: 'good',
                        message: "‚úÖ SnowBored Game deployed successfully!\nBuild: ${BUILD_NUMBER}\nCommit: ${env.GIT_COMMIT_SHORT}\nImage: ${DOCKER_REGISTRY_USR}/${DOCKER_IMAGE}:${DOCKER_TAG}"
                    )
                }
                failure {
                    echo 'Docker push failed!'
                    
                    slackSend(
                        channel: '#deployments',
                        color: 'danger',
                        message: "‚ùå SnowBored Game deployment failed!\nBuild: ${BUILD_NUMBER}\nCommit: ${env.GIT_COMMIT_SHORT}"
                    )
                }
            }
        }
        
        stage('Deploy to Staging') {
            when {
                branch 'develop'
            }
            steps {
                echo 'Deploying to staging environment...'
                sh '''
                    # Stop existing container if running
                    docker stop snowbored-staging || true
                    docker rm snowbored-staging || true
                    
                    # Run new container
                    docker run -d \
                        --name snowbored-staging \
                        -p 3001:3000 \
                        --restart unless-stopped \
                        ${DOCKER_IMAGE}:${DOCKER_TAG}
                    
                    # Health check
                    sleep 10
                    curl -f http://localhost:3001 || exit 1
                '''
            }
        }
        
        stage('Deploy to Production') {
            when {
                anyOf {
                    branch 'main'
                    branch 'master'
                }
            }
            steps {
                echo 'Deploying to production environment...'
                
                // Manual approval for production
                input message: 'Deploy to Production?', ok: 'Deploy',
                      submitterParameter: 'DEPLOYER'
                
                sh '''
                    # Blue-green deployment strategy
                    
                    # Stop and remove old container
                    docker stop snowbored-prod || true
                    docker rm snowbored-prod || true
                    
                    # Start new container
                    docker run -d \
                        --name snowbored-prod \
                        -p 3000:3000 \
                        --restart unless-stopped \
                        -e NODE_ENV=production \
                        ${DOCKER_IMAGE}:${DOCKER_TAG}
                    
                    # Health check
                    sleep 15
                    curl -f http://localhost:3000 || exit 1
                    
                    echo "Production deployment completed successfully!"
                '''
            }
            post {
                success {
                    echo "üöÄ Production deployment successful!"
                    
                    slackSend(
                        channel: '#deployments',
                        color: 'good',
                        message: "üöÄ SnowBored Game PRODUCTION deployment successful!\nDeployed by: ${env.DEPLOYER}\nBuild: ${BUILD_NUMBER}\nCommit: ${env.GIT_COMMIT_SHORT}"
                    )
                }
            }
        }
        
        stage('Archive Artifacts') {
            steps {
                echo 'Archiving build artifacts...'
                
                // Create artifacts directory
                sh '''
                    mkdir -p artifacts
                    
                    # Copy build files
                    cp -r .next artifacts/ || true
                    cp -r public artifacts/ || true
                    cp package.json artifacts/
                    cp Dockerfile artifacts/
                    
                    # Create tarball
                    tar -czf snowbored-artifacts-${BUILD_NUMBER}.tar.gz artifacts/
                '''
                
                // Archive artifacts
                archiveArtifacts artifacts: 'snowbored-artifacts-*.tar.gz', fingerprint: true
                
                // Archive test reports
                archiveArtifacts artifacts: 'coverage/**/*', allowEmptyArchive: true
            }
        }
    }
    
    post {
        always {
            echo 'Pipeline completed!'
            
            // Clean up Docker images to save space
            sh '''
                docker image prune -f
                docker system prune -f --volumes
            '''
            
            // Clean workspace
            cleanWs()
        }
        
        success {
            echo '‚úÖ Pipeline executed successfully!'
            
            emailext (
                subject: "‚úÖ Jenkins Build Success: SnowBored Game #${BUILD_NUMBER}",
                body: """
                    <h2>Build Successful! üéâ</h2>
                    <p><strong>Project:</strong> SnowBored Game</p>
                    <p><strong>Build Number:</strong> ${BUILD_NUMBER}</p>
                    <p><strong>Git Commit:</strong> ${env.GIT_COMMIT_SHORT}</p>
                    <p><strong>Branch:</strong> ${env.BRANCH_NAME}</p>
                    <p><strong>Duration:</strong> ${currentBuild.durationString}</p>
                    
                    <h3>Stages Completed:</h3>
                    <ul>
                        <li>‚úÖ Build</li>
                        <li>‚úÖ Test</li>
                        <li>‚úÖ Docker Build</li>
                        <li>‚úÖ Docker Push</li>
                        <li>‚úÖ Deploy</li>
                    </ul>
                    
                    <p><a href="${BUILD_URL}">View Build Details</a></p>
                """,
                to: "${env.CHANGE_AUTHOR_EMAIL}",
                mimeType: 'text/html'
            )
        }
        
        failure {
            echo '‚ùå Pipeline failed!'
            
            emailext (
                subject: "‚ùå Jenkins Build Failed: SnowBored Game #${BUILD_NUMBER}",
                body: """
                    <h2>Build Failed! ‚ùå</h2>
                    <p><strong>Project:</strong> SnowBored Game</p>
                    <p><strong>Build Number:</strong> ${BUILD_NUMBER}</p>
                    <p><strong>Git Commit:</strong> ${env.GIT_COMMIT_SHORT}</p>
                    <p><strong>Branch:</strong> ${env.BRANCH_NAME}</p>
                    <p><strong>Failed Stage:</strong> ${env.STAGE_NAME}</p>
                    
                    <p><a href="${BUILD_URL}console">View Console Output</a></p>
                """,
                to: "${env.CHANGE_AUTHOR_EMAIL}",
                mimeType: 'text/html'
            )
        }
        
        unstable {
            echo '‚ö†Ô∏è Pipeline completed with warnings!'
        }
    }
}
